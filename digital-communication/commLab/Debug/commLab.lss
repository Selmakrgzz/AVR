
commLab.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         00000000  00803f00  00803f00  00000202  2**0
                  ALLOC, LOAD, DATA
  1 .text         0000008a  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .comment      0000002f  00000000  00000000  00000202  2**0
                  CONTENTS, READONLY
  3 .stack.descriptors.hdr 0000000e  00000000  00000000  00000231  2**0
                  CONTENTS, READONLY
  4 .debug_aranges 00000040  00000000  00000000  0000023f  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .debug_info   00001f99  00000000  00000000  0000027f  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_abbrev 00001666  00000000  00000000  00002218  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_line   0000030d  00000000  00000000  0000387e  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_frame  00000094  00000000  00000000  00003b8c  2**2
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_str    00000962  00000000  00000000  00003c20  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_loc    0000009f  00000000  00000000  00004582  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_ranges 00000030  00000000  00000000  00004621  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .text         00000002  00000164  00000164  000001f8  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 13 .note.gnu.avr.deviceinfo 0000003c  00000000  00000000  00004654  2**2
                  CONTENTS, READONLY, DEBUGGING
 14 .text.setup_usart 0000001c  0000011e  0000011e  000001b2  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 15 .text.setup_tcb 0000001c  0000013a  0000013a  000001ce  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 16 .text.main    00000026  000000f8  000000f8  0000018c  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 17 .text.__vector_13 0000002e  000000ca  000000ca  0000015e  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 18 .text.__vector_22 00000040  0000008a  0000008a  0000011e  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 19 .bss.number   00000001  00803f00  00803f00  00000202  2**0
                  ALLOC
 20 .text.__dummy_fini 00000002  00000166  00000166  000001fa  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 21 .text.__dummy_funcs_on_exit 00000002  00000168  00000168  000001fc  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 22 .text.__dummy_simulator_exit 00000002  0000016a  0000016a  000001fe  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 23 .text.exit    0000000e  00000156  00000156  000001ea  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 24 .text._Exit   00000002  0000016c  0000016c  00000200  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE

Disassembly of section .text:

00000000 <__vectors>:
   0:	1c c0       	rjmp	.+56     	; 0x3a <__ctors_end>
   2:	b0 c0       	rjmp	.+352    	; 0x164 <__bad_interrupt>
   4:	af c0       	rjmp	.+350    	; 0x164 <__bad_interrupt>
   6:	ae c0       	rjmp	.+348    	; 0x164 <__bad_interrupt>
   8:	ad c0       	rjmp	.+346    	; 0x164 <__bad_interrupt>
   a:	ac c0       	rjmp	.+344    	; 0x164 <__bad_interrupt>
   c:	ab c0       	rjmp	.+342    	; 0x164 <__bad_interrupt>
   e:	aa c0       	rjmp	.+340    	; 0x164 <__bad_interrupt>
  10:	a9 c0       	rjmp	.+338    	; 0x164 <__bad_interrupt>
  12:	a8 c0       	rjmp	.+336    	; 0x164 <__bad_interrupt>
  14:	a7 c0       	rjmp	.+334    	; 0x164 <__bad_interrupt>
  16:	a6 c0       	rjmp	.+332    	; 0x164 <__bad_interrupt>
  18:	a5 c0       	rjmp	.+330    	; 0x164 <__bad_interrupt>
  1a:	57 c0       	rjmp	.+174    	; 0xca <__vector_13>
  1c:	a3 c0       	rjmp	.+326    	; 0x164 <__bad_interrupt>
  1e:	a2 c0       	rjmp	.+324    	; 0x164 <__bad_interrupt>
  20:	a1 c0       	rjmp	.+322    	; 0x164 <__bad_interrupt>
  22:	a0 c0       	rjmp	.+320    	; 0x164 <__bad_interrupt>
  24:	9f c0       	rjmp	.+318    	; 0x164 <__bad_interrupt>
  26:	9e c0       	rjmp	.+316    	; 0x164 <__bad_interrupt>
  28:	9d c0       	rjmp	.+314    	; 0x164 <__bad_interrupt>
  2a:	9c c0       	rjmp	.+312    	; 0x164 <__bad_interrupt>
  2c:	2e c0       	rjmp	.+92     	; 0x8a <_etext>
  2e:	9a c0       	rjmp	.+308    	; 0x164 <__bad_interrupt>
  30:	99 c0       	rjmp	.+306    	; 0x164 <__bad_interrupt>
  32:	98 c0       	rjmp	.+304    	; 0x164 <__bad_interrupt>

00000034 <.dinit>:
  34:	3f 00       	.word	0x003f	; ????
  36:	3f 01       	movw	r6, r30
  38:	80 00       	.word	0x0080	; ????

0000003a <__ctors_end>:
  3a:	11 24       	eor	r1, r1
  3c:	1f be       	out	0x3f, r1	; 63
  3e:	cf ef       	ldi	r28, 0xFF	; 255
  40:	cd bf       	out	0x3d, r28	; 61
  42:	df e3       	ldi	r29, 0x3F	; 63
  44:	de bf       	out	0x3e, r29	; 62

00000046 <__do_copy_data>:
  46:	e4 e3       	ldi	r30, 0x34	; 52
  48:	f0 e0       	ldi	r31, 0x00	; 0
  4a:	40 e0       	ldi	r20, 0x00	; 0
  4c:	17 c0       	rjmp	.+46     	; 0x7c <__do_clear_bss+0x8>
  4e:	b5 91       	lpm	r27, Z+
  50:	a5 91       	lpm	r26, Z+
  52:	35 91       	lpm	r19, Z+
  54:	25 91       	lpm	r18, Z+
  56:	05 91       	lpm	r16, Z+
  58:	07 fd       	sbrc	r16, 7
  5a:	0c c0       	rjmp	.+24     	; 0x74 <__do_clear_bss>
  5c:	95 91       	lpm	r25, Z+
  5e:	85 91       	lpm	r24, Z+
  60:	ef 01       	movw	r28, r30
  62:	f9 2f       	mov	r31, r25
  64:	e8 2f       	mov	r30, r24
  66:	05 90       	lpm	r0, Z+
  68:	0d 92       	st	X+, r0
  6a:	a2 17       	cp	r26, r18
  6c:	b3 07       	cpc	r27, r19
  6e:	d9 f7       	brne	.-10     	; 0x66 <__do_copy_data+0x20>
  70:	fe 01       	movw	r30, r28
  72:	04 c0       	rjmp	.+8      	; 0x7c <__do_clear_bss+0x8>

00000074 <__do_clear_bss>:
  74:	1d 92       	st	X+, r1
  76:	a2 17       	cp	r26, r18
  78:	b3 07       	cpc	r27, r19
  7a:	e1 f7       	brne	.-8      	; 0x74 <__do_clear_bss>
  7c:	e9 33       	cpi	r30, 0x39	; 57
  7e:	f4 07       	cpc	r31, r20
  80:	31 f7       	brne	.-52     	; 0x4e <__do_copy_data+0x8>
  82:	3a d0       	rcall	.+116    	; 0xf8 <main>
  84:	68 c0       	rjmp	.+208    	; 0x156 <exit>

00000086 <_exit>:
  86:	f8 94       	cli

00000088 <__stop_program>:
  88:	ff cf       	rjmp	.-2      	; 0x88 <__stop_program>

Disassembly of section .text:

00000164 <__bad_interrupt>:
 164:	4d cf       	rjmp	.-358    	; 0x0 <__TEXT_REGION_ORIGIN__>

Disassembly of section .text.setup_usart:

0000011e <setup_usart>:
#define F_CPU 3333333
#define USART_BAUD_RATE(BAUD_RATE) ((float)(F_CPU * 64 / (16 * (float)BAUD_RATE)) + 0.5)
uint8_t number = 0;

void setup_usart(){
	PORTB.DIRSET = PIN2_bm; // set high
 11e:	84 e0       	ldi	r24, 0x04	; 4
 120:	80 93 21 04 	sts	0x0421, r24	; 0x800421 <__RODATA_PM_OFFSET__+0x7f8421>
	USART0.BAUD = (uint8_t) USART_BAUD_RATE(BAUD_RATE); // set baud rate
 124:	e0 e0       	ldi	r30, 0x00	; 0
 126:	f8 e0       	ldi	r31, 0x08	; 8
 128:	84 e7       	ldi	r24, 0x74	; 116
 12a:	90 e0       	ldi	r25, 0x00	; 0
 12c:	80 87       	std	Z+8, r24	; 0x08
 12e:	91 87       	std	Z+9, r25	; 0x09
	USART0.CTRLB = USART_TXEN_bm | USART_RXEN_bm; // enable the transmitter and receiver
 130:	80 ec       	ldi	r24, 0xC0	; 192
 132:	86 83       	std	Z+6, r24	; 0x06
	USART0.CTRLA = USART_RXCIE_bm; // set unread data from receiver in control register A
 134:	80 e8       	ldi	r24, 0x80	; 128
 136:	85 83       	std	Z+5, r24	; 0x05
 138:	08 95       	ret

Disassembly of section .text.setup_tcb:

0000013a <setup_tcb>:
}

void setup_tcb(){
	uint8_t TOP = 255; // set top value when the interrupts hits
	TCB0.CCMP = TOP; // something
 13a:	e0 e4       	ldi	r30, 0x40	; 64
 13c:	fa e0       	ldi	r31, 0x0A	; 10
 13e:	8f ef       	ldi	r24, 0xFF	; 255
 140:	90 e0       	ldi	r25, 0x00	; 0
 142:	84 87       	std	Z+12, r24	; 0x0c
 144:	95 87       	std	Z+13, r25	; 0x0d
	TCB0.CTRLB = TCB_CNTMODE_SINGLE_gc; // something (for å ikke overskrive noe bruk =|)
 146:	86 e0       	ldi	r24, 0x06	; 6
 148:	81 83       	std	Z+1, r24	; 0x01
	TCB0.INTCTRL = TCB_CAPT_bm; // starts the interrupt
 14a:	81 e0       	ldi	r24, 0x01	; 1
 14c:	85 83       	std	Z+5, r24	; 0x05
	TCB0.CTRLA = TCB_CLKSEL_CLKDIV2_gc; // clock speed
 14e:	92 e0       	ldi	r25, 0x02	; 2
 150:	90 83       	st	Z, r25
	TCB0.CTRLA = TCB_ENABLE_bm; // enable interrupt
 152:	80 83       	st	Z, r24
 154:	08 95       	ret

Disassembly of section .text.main:

000000f8 <main>:
}


int main(void)
{
	PORTA.DIRSET = PIN5_bm;
  f8:	e0 e0       	ldi	r30, 0x00	; 0
  fa:	f4 e0       	ldi	r31, 0x04	; 4
  fc:	80 e2       	ldi	r24, 0x20	; 32
  fe:	81 83       	std	Z+1, r24	; 0x01
	PORTA.OUTSET = PIN5_bm;
 100:	85 83       	std	Z+5, r24	; 0x05
	PORTA.PIN7CTRL = PORT_PULLUPEN_bm;
 102:	88 e0       	ldi	r24, 0x08	; 8
 104:	87 8b       	std	Z+23, r24	; 0x17
	
    while(1)
    {
        //TODO:: Please write your application code 
		setup_usart();
 106:	0b d0       	rcall	.+22     	; 0x11e <setup_usart>
		setup_tcb();
 108:	18 d0       	rcall	.+48     	; 0x13a <setup_tcb>
		sei();
 10a:	78 94       	sei
		
		if(!(PORTA.IN & PIN7_bm)) {
 10c:	80 91 08 04 	lds	r24, 0x0408	; 0x800408 <__RODATA_PM_OFFSET__+0x7f8408>
 110:	88 23       	and	r24, r24
 112:	cc f3       	brlt	.-14     	; 0x106 <__DATA_REGION_LENGTH__+0x6>
			USART0.TXDATAL = number; // load transmit buffer with the data we want to send
 114:	80 91 00 3f 	lds	r24, 0x3F00	; 0x803f00 <__DATA_REGION_ORIGIN__>
 118:	80 93 02 08 	sts	0x0802, r24	; 0x800802 <__RODATA_PM_OFFSET__+0x7f8802>
 11c:	f4 cf       	rjmp	.-24     	; 0x106 <__DATA_REGION_LENGTH__+0x6>

Disassembly of section .text.__vector_13:

000000ca <__vector_13>:
		}
		
    }
}

ISR(TCB0_INT_vect) {
  ca:	1f 92       	push	r1
  cc:	0f 92       	push	r0
  ce:	0f b6       	in	r0, 0x3f	; 63
  d0:	0f 92       	push	r0
  d2:	11 24       	eor	r1, r1
  d4:	8f 93       	push	r24
  d6:	ef 93       	push	r30
  d8:	ff 93       	push	r31
	
	TCB0.INTFLAGS = TCB_CAPT_bm;
  da:	e0 e4       	ldi	r30, 0x40	; 64
  dc:	fa e0       	ldi	r31, 0x0A	; 10
  de:	81 e0       	ldi	r24, 0x01	; 1
  e0:	86 83       	std	Z+6, r24	; 0x06
	TCB0.CNT = 0;
  e2:	12 86       	std	Z+10, r1	; 0x0a
  e4:	13 86       	std	Z+11, r1	; 0x0b
	TCB0.CTRLA = TCB_ENABLE_bm;
  e6:	80 83       	st	Z, r24
}
  e8:	ff 91       	pop	r31
  ea:	ef 91       	pop	r30
  ec:	8f 91       	pop	r24
  ee:	0f 90       	pop	r0
  f0:	0f be       	out	0x3f, r0	; 63
  f2:	0f 90       	pop	r0
  f4:	1f 90       	pop	r1
  f6:	18 95       	reti

Disassembly of section .text.__vector_22:

0000008a <__vector_22>:

ISR(USART0_RXC_vect) {
  8a:	1f 92       	push	r1
  8c:	0f 92       	push	r0
  8e:	0f b6       	in	r0, 0x3f	; 63
  90:	0f 92       	push	r0
  92:	11 24       	eor	r1, r1
  94:	8f 93       	push	r24
  96:	9f 93       	push	r25
	number = USART0.RXDATAL;
  98:	80 91 00 08 	lds	r24, 0x0800	; 0x800800 <__RODATA_PM_OFFSET__+0x7f8800>
	PORTA.OUTTGL = PIN5_bm;
  9c:	90 e2       	ldi	r25, 0x20	; 32
  9e:	90 93 07 04 	sts	0x0407, r25	; 0x800407 <__RODATA_PM_OFFSET__+0x7f8407>


	if (number < 255) {
  a2:	8f 3f       	cpi	r24, 0xFF	; 255
  a4:	31 f0       	breq	.+12     	; 0xb2 <__vector_22+0x28>
		number++;
  a6:	8f 5f       	subi	r24, 0xFF	; 255
  a8:	80 93 00 3f 	sts	0x3F00, r24	; 0x803f00 <__DATA_REGION_ORIGIN__>
		USART0.TXDATAL = number;
  ac:	80 93 02 08 	sts	0x0802, r24	; 0x800802 <__RODATA_PM_OFFSET__+0x7f8802>
  b0:	05 c0       	rjmp	.+10     	; 0xbc <__vector_22+0x32>
	} else {
		PORTA.OUTSET = PIN7_bm;
  b2:	80 e8       	ldi	r24, 0x80	; 128
  b4:	80 93 05 04 	sts	0x0405, r24	; 0x800405 <__RODATA_PM_OFFSET__+0x7f8405>
		number = 0;
  b8:	10 92 00 3f 	sts	0x3F00, r1	; 0x803f00 <__DATA_REGION_ORIGIN__>
	}
  bc:	9f 91       	pop	r25
  be:	8f 91       	pop	r24
  c0:	0f 90       	pop	r0
  c2:	0f be       	out	0x3f, r0	; 63
  c4:	0f 90       	pop	r0
  c6:	1f 90       	pop	r1
  c8:	18 95       	reti

Disassembly of section .text.__dummy_fini:

00000166 <_fini>:
 166:	08 95       	ret

Disassembly of section .text.__dummy_funcs_on_exit:

00000168 <__funcs_on_exit>:
 168:	08 95       	ret

Disassembly of section .text.__dummy_simulator_exit:

0000016a <__simulator_exit>:
 16a:	08 95       	ret

Disassembly of section .text.exit:

00000156 <exit>:
 156:	ec 01       	movw	r28, r24
 158:	07 d0       	rcall	.+14     	; 0x168 <__funcs_on_exit>
 15a:	05 d0       	rcall	.+10     	; 0x166 <_fini>
 15c:	ce 01       	movw	r24, r28
 15e:	05 d0       	rcall	.+10     	; 0x16a <__simulator_exit>
 160:	ce 01       	movw	r24, r28
 162:	04 d0       	rcall	.+8      	; 0x16c <_Exit>

Disassembly of section .text._Exit:

0000016c <_Exit>:
 16c:	8c df       	rcall	.-232    	; 0x86 <_exit>
